from PyQt6.QtCore import Qt
import sys
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QPushButton, QLabel, QFileDialog, QMessageBox, QHBoxLayout, QCheckBox
)
from tools.convert_spa import convert_spa_files
from tools.clean_rruff import clean_rruff_files
from tools.plot_utils import plot_selected_spectra
import os

class IRViewer(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Infrared Spectral Analysis Tool")
        self.resize(400, 500)
        self.current_fig = None
        # Define sample and reference folder paths
        self.sample_folder = os.path.join("data", "samples")
        self.reference_folder = os.path.join("data", "references")
        self.init_ui()

    def init_ui(self):
        main_layout = QVBoxLayout()

        title = QLabel("Infrared Spectral Analysis")
        title.setStyleSheet("font-size: 20px; font-weight: bold; padding: 10px;")
        main_layout.addWidget(title)

        btn_convert = QPushButton("Convert SPA to CSV")
        btn_convert.clicked.connect(self.convert_spa)
        main_layout.addWidget(btn_convert)

        btn_clean_rruff = QPushButton("Clean RRUFF Database")
        btn_clean_rruff.clicked.connect(self.clean_rruff)
        main_layout.addWidget(btn_clean_rruff)

        # Deactivated add sample/ref button, user should add them manually into program files

        # button_row = QHBoxLayout()

        # btn_add_sample = QPushButton("Add Sample CSV")
        # btn_add_sample.clicked.connect(self.add_sample_csv)
        # button_row.addWidget(btn_add_sample)

        # btn_add_reference = QPushButton("Add Reference CSV")
        # btn_add_reference.clicked.connect(self.add_reference_csv)
        # button_row.addWidget(btn_add_reference)

        # main_layout.addLayout(button_row)

        btn_plot = QPushButton("Plot Spectra")
        btn_plot.clicked.connect(self.plot_spectra)
        main_layout.addWidget(btn_plot)

        from PyQt6.QtWidgets import QMenu

        analysis_menu = QMenu()
        analysis_menu.addAction("Derivative Regression", self.run_derivative_regression)
        analysis_menu.addAction("PCA Analysis", self.run_pca_analysis)
        analysis_menu.addAction("Correlation Analysis", self.run_correlation_analysis)
        analysis_menu.addAction("NMF Analysis", lambda: QMessageBox.information(self, "Info", "NMF Analysis not yet implemented."))
        analysis_menu.addAction("PLS Analysis", lambda: QMessageBox.information(self, "Info", "PLS Analysis not yet implemented."))

        btn_analysis = QPushButton("Run Analysis")
        btn_analysis.setStyleSheet("text-align: center;")
        btn_analysis.setMenu(analysis_menu)
        main_layout.addWidget(btn_analysis)

        # Add "Run Batch Analysis" dropdown button with only "Correlation Analysis" as an option
        batch_analysis_menu = QMenu()
        batch_analysis_menu.addAction("Correlation Analysis", self.run_batch_analysis)

        btn_batch_analysis = QPushButton("Run Batch Analysis")
        btn_batch_analysis.setStyleSheet("text-align: center;")
        btn_batch_analysis.setMenu(batch_analysis_menu)
        main_layout.addWidget(btn_batch_analysis)

        # Add circular info button at top-right corner
        info_button = QPushButton("i")
        info_button.setFixedSize(24, 24)
        info_button.setStyleSheet("""
            QPushButton {
                border-radius: 12px;
                background-color: #656565;
                font-weight: bold;
                font-size: 14px;
            }
        """)
        info_button.setToolTip("Click for info")
        info_button.clicked.connect(self.show_info_window)

        # Overlay layout for top-right
        overlay_layout = QHBoxLayout()
        overlay_layout.addStretch()
        overlay_layout.addWidget(info_button)

        wrapper_layout = QVBoxLayout()
        wrapper_layout.addLayout(overlay_layout)
        wrapper_layout.addLayout(main_layout)

        self.setLayout(wrapper_layout)

    def show_info_window(self):
        from PyQt6.QtWidgets import QMainWindow, QWidget, QVBoxLayout, QTextEdit
        info_window = QMainWindow(self)
        info_window.setWindowTitle("Program Instructions")
        info_window.setGeometry(100, 100, 700, 400)

        central_widget = QWidget()
        layout = QVBoxLayout(central_widget)

        info_text = QTextEdit()
        info_text.setReadOnly(True)
        info_text.setHtml("""
        <i>This program was developed by Andie Park as part of the New Jersey Governor's School in the Sciences 2025 Archaeology Research Project. Credit to Darby Ko for interpolation logic in correlations and unused prototype script.</i>
        <h2>How to Use This Program</h2>
        <p>This program allows you to visualize and analyze FT-IR spectra data.</p>
        <h3>Step 1: Input Files</h3>
        <ul>
          <li>Obtain .SPA files generated by Nicolet iS10, iZ10, or 6700 FT-IR spectrometers using Thermo Scientific™ OMNIC™ Specta Software.</li>
          <li>Download reference spectra in CSV format from RRUFF or NIST databases.</li>
        </ul>
        <h3>Step 2: Plotting Spectra</h3>
        <ul>
          <li>After loading sample and reference files, choose between:</li>
          <ul>
            <li><b>Stacked View</b> - Each spectrum is displayed in its own subplot.
        <img src="resources/stacked_view.jpg" width="600"><br><br>
            <li><b>Overlay View</b> - All spectra appear on the same plot for comparison.            
        <img src="resources/overlay_view.jpg" width="600"><br><br>
          </ul>
        </ul>
        <h3>Step 3: Analysis</h3>
        <ul>
          <li>Select samples and references.</li>
          <li>Batch correlation analysis results are saved in the <code>outputs</code> folder.</li>
          <li></li>
        </ul>
        """)

        layout.addWidget(info_text)
        info_window.setCentralWidget(central_widget)
        info_window.show()

    def convert_spa(self):
        files, _ = QFileDialog.getOpenFileNames(self, "Select SPA Files", "", "SPA Files (*.spa)")
        if files:
            try:
                convert_spa_files(files)
                QMessageBox.information(self, "Success", f"Converted {len(files)} SPA file(s).")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Conversion failed:\n{str(e)}")

    def clean_rruff(self):
        files, _ = QFileDialog.getOpenFileNames(self, "Select RRUFF Files", "", "Text Files (*.txt)")
        if files:
            try:
                clean_rruff_files(files)
                QMessageBox.information(self, "Success", f"Cleaned {len(files)} RRUFF file(s).")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Cleaning failed:\n{str(e)}")

    def plot_spectra(self, file_paths=None, stacked=False):
        # Check for sample files before plotting
        if not os.listdir(self.sample_folder):
            QMessageBox.warning(self, "No Samples", "No sample files found. Please upload files first.")
            return
        sample_paths = self.create_searchable_file_dialog("Select Sample Spectra", self.sample_folder)
        reference_paths = self.create_searchable_file_dialog("Select Reference Spectra", self.reference_folder)

        if sample_paths or reference_paths:
            # Ask for plot display mode before plotting
            plot_mode = self.ask_plot_mode()
            if plot_mode is None:
                return  # User cancelled
            try:
                fig = plot_selected_spectra(sample_paths, reference_paths, plot_mode=plot_mode)
                self.current_fig = fig
                self.show_plot_window(fig)
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Plotting failed:\n{str(e)}")
        else:
            QMessageBox.information(self, "No Selection", "No files were selected.")
    def ask_plot_mode(self):
        msg_box = QMessageBox()
        msg_box.setWindowTitle("Plot Mode Selection")
        msg_box.setText("Choose how to display the spectra:")
        overlay_button = msg_box.addButton("Overlay View", QMessageBox.ButtonRole.AcceptRole)
        stacked_button = msg_box.addButton("Stacked View", QMessageBox.ButtonRole.AcceptRole)
        msg_box.exec()

        if msg_box.clickedButton() == stacked_button:
            return "stacked"
        else:
            return "overlay"

    def show_plot_window(self, fig):
        import matplotlib.pyplot as plt
        ax = fig.gca()
        legend = ax.legend(
            loc='best',
            frameon=True,
            fontsize=9,
            labelspacing=0.3,
            handlelength=1.5,
            ncol=1,
            borderpad=0.5
        )
        fig.tight_layout()  # Maintain layout without figure resize
        plt.figure(fig.number)
        plt.show()

    def add_sample_csv(self):       # deactivated
        files, _ = QFileDialog.getOpenFileNames(self, "Add Sample CSV", "", "CSV Files (*.csv)")
        if files:
            os.makedirs("data/samples", exist_ok=True)
            for f in files:
                dest = os.path.join("data/samples", os.path.basename(f))
                try:
                    if os.path.abspath(f) != os.path.abspath(dest):
                        with open(f, 'rb') as src_file, open(dest, 'wb') as dst_file:
                            dst_file.write(src_file.read())
                except Exception as e:
                    QMessageBox.warning(self, "Error", f"Could not copy {f}:\n{e}")
            QMessageBox.information(self, "Success", f"Added {len(files)} sample file(s).")



    def add_reference_csv(self):        # deactivated
        files, _ = QFileDialog.getOpenFileNames(self, "Add Reference CSV", "", "CSV Files (*.csv)")
        if files:
            os.makedirs("data/references", exist_ok=True)
            for f in files:
                dest = os.path.join("data/references", os.path.basename(f))
                try:
                    if os.path.abspath(f) != os.path.abspath(dest):
                        with open(f, 'rb') as src_file, open(dest, 'wb') as dst_file:
                            dst_file.write(src_file.read())
                except Exception as e:
                    QMessageBox.warning(self, "Error", f"Could not copy {f}:\n{e}")
            QMessageBox.information(self, "Success", f"Added {len(files)} reference file(s).")

    def run_derivative_regression(self):
        from tools.analysis.regressions import run_derivative_regression_analysis
        import os

        # Allow only 1 or 2 selections, no select all
        sample_paths = self.create_searchable_file_dialog("Select ONE or TWO Sample Files", "data/samples")
        if not sample_paths or len(sample_paths) not in [1, 2]:
            QMessageBox.warning(self, "Invalid Selection", "Please select ONE or TWO sample files.")
            return

        reference_paths = []
        if len(sample_paths) == 1:
            reference_paths = self.create_searchable_file_dialog("Select ONE Reference File", "data/references")
            if len(reference_paths) != 1:
                QMessageBox.warning(self, "Invalid Selection", "Please select exactly ONE reference file.")
                return
            comparison_type = "reference"
        else:
            comparison_type = "sample"

        try:
            import matplotlib.pyplot as plt
            plt.close('all')
            if comparison_type == "reference":
                run_derivative_regression_analysis(sample_paths[0], reference_paths[0], comparison_type=comparison_type)
            else:
                run_derivative_regression_analysis(sample_paths[0], sample_paths[1], comparison_type=comparison_type)
            QMessageBox.information(self, "Success", "Derivative regression analysis completed and plots saved.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Analysis failed:\n{str(e)}")

    def get_checked_files(self, title, folder, allow_multiple=True, show_select_all=True):
        from PyQt6.QtWidgets import QDialog, QListWidget, QListWidgetItem, QPushButton, QVBoxLayout, QLineEdit
        dialog = QDialog(self)
        dialog.setWindowTitle(title)
        layout = QVBoxLayout()

        search_bar = QLineEdit()
        search_bar.setPlaceholderText("Search...")
        layout.addWidget(search_bar)

        list_widget = QListWidget()
        files = [f for f in os.listdir(folder) if f.endswith('.csv')]
        file_items = {}  # store mapping for filter
        for file in files:
            display_name = file.replace('.csv', '')
            item = QListWidgetItem(display_name)
            item.setCheckState(Qt.CheckState.Unchecked)
            list_widget.addItem(item)
            file_items[display_name] = item
        layout.addWidget(list_widget)

        def filter_list(text):
            list_widget.clear()
            for name in sorted(file_items.keys()):
                if text.lower() in name.lower():
                    item = QListWidgetItem(name)
                    # Preserve checked state from existing item
                    original_item = file_items[name]
                    item.setCheckState(original_item.checkState())
                    list_widget.addItem(item)
                    file_items[name] = item  # Re-bind to keep toggle selection working

        search_bar.textChanged.connect(filter_list)

        # Ensure list_widget emits itemChanged signal for tracking selection
        # Insert itemChanged connection here (for new toggle logic)
        # (No effect if not used; safe to always connect)
        def dummy_update(): pass
        list_widget.itemChanged.connect(dummy_update)

        if show_select_all:
            # Replace the old select all logic with toggle select logic
            btn_toggle_select = QPushButton("Select All")
            layout.addWidget(btn_toggle_select)

            def update_toggle_button():
                all_checked = all(list_widget.item(i).checkState() == Qt.CheckState.Checked for i in range(list_widget.count()))
                btn_toggle_select.setText("Unselect All" if all_checked else "Select All")

            def toggle_selection():
                all_checked = all(list_widget.item(i).checkState() == Qt.CheckState.Checked for i in range(list_widget.count()))
                new_state = Qt.CheckState.Unchecked if all_checked else Qt.CheckState.Checked
                for i in range(list_widget.count()):
                    list_widget.item(i).setCheckState(new_state)
                update_toggle_button()

            btn_toggle_select.clicked.connect(toggle_selection)
            list_widget.itemChanged.connect(update_toggle_button)
            # Remove dummy_update connection if present
            # (PyQt6 allows multiple connections, but we can ignore)
        else:
            # If not showing select all, still want itemChanged for search filter to preserve check states
            def update_toggle_button(): pass
            # Already connected dummy_update above

        btn_ok = QPushButton("OK")
        layout.addWidget(btn_ok)
        dialog.setLayout(layout)

        def accept():
            dialog.accept()
        btn_ok.clicked.connect(accept)

        dialog.exec()

        selected = [
            os.path.join(folder, list_widget.item(i).text() + '.csv')
            for i in range(list_widget.count())
            if list_widget.item(i).checkState() == Qt.CheckState.Checked
        ]

        if not allow_multiple and len(selected) > 1:
            QMessageBox.warning(self, "Selection Error", "Please select only one file.")
            return []

        return selected

    def run_pca_analysis(self):
        # Check for sample files before analysis
        if not os.listdir(self.sample_folder):
            QMessageBox.warning(self, "No Samples", "No sample files found. Please upload files first.")
            return
        try:
            sample_paths = self.create_searchable_file_dialog("Select Sample Spectra", self.sample_folder)
            reference_paths = self.create_searchable_file_dialog("Select Reference Spectra", self.reference_folder)

            if not sample_paths and not reference_paths:
                QMessageBox.information(self, "No Selection", "No files were selected.")
                return
            
            from tools.analysis.run_pca import run_pca_analysis
            result = run_pca_analysis(sample_paths, reference_paths)
            self.current_fig = result["figure"]
            self.show_plot_window(self.current_fig)

        except Exception as e:
            QMessageBox.critical(self, "Error", f"PCA analysis failed:\n{str(e)}")

    def run_correlation_analysis(self):
        from tools.analysis.correlations import run_correlation_analysis
        import os

        # Check for sample files before analysis
        if not os.listdir(self.sample_folder):
            QMessageBox.warning(self, "No Samples", "No sample files found. Please upload files first.")
            return

        # Allow only 1 or 2 selections, no select all
        sample_paths = self.create_searchable_file_dialog("Select ONE or TWO Sample Files", self.sample_folder)
        if not sample_paths or len(sample_paths) not in [1, 2]:
            QMessageBox.warning(self, "Invalid Selection", "Please select ONE or TWO sample files.")
            return

        if len(sample_paths) == 1:
            # Check for reference files before analysis
            if not os.listdir(self.reference_folder):
                QMessageBox.warning(self, "No Reference Files", "No reference files found. Please upload reference files first.")
                return
            reference_paths = self.create_searchable_file_dialog("Select ONE Reference File", self.reference_folder)
            if len(reference_paths) != 1:
                QMessageBox.warning(self, "Invalid Selection", "Please select exactly ONE reference file.")
                return
        else:
            reference_paths = []

        # Decide on interpolation usage
        use_interpolation = bool(reference_paths)  # Enable interpolation only if reference files are present

        # Prepare arguments for backend
        if len(sample_paths) == 1:
            file1 = sample_paths[0]
            file2 = reference_paths[0]
        else:
            file1, file2 = sample_paths

        try:
            pearson_r, spearman_rho = run_correlation_analysis(file1, file2, use_interpolation)
            result_msg = f"Pearson's R: {pearson_r:.4f}\nSpearman's ρ: {spearman_rho:.4f}"
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("Correlation Results")
            msg_box.setText(result_msg)
            copy_button = msg_box.addButton("Copy", QMessageBox.ButtonRole.ActionRole)
            msg_box.addButton("Close", QMessageBox.ButtonRole.RejectRole)
            msg_box.exec()

            if msg_box.clickedButton() == copy_button:
                QApplication.clipboard().setText(result_msg)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Correlation analysis failed:\n{str(e)}")

    def run_batch_analysis(self):
        from PyQt6.QtWidgets import QDialog, QPushButton, QVBoxLayout, QComboBox, QMessageBox
        from tools.analysis.correlations import run_correlation_analysis
        import os
        import pandas as pd
        import datetime

        # Check for sample files before batch analysis
        if not os.listdir(self.sample_folder):
            QMessageBox.warning(self, "No Samples", "No sample files found. Please upload files first.")
            return

        dialog = QDialog(self)
        dialog.setWindowTitle("Select Batch Mode")
        layout = QVBoxLayout()

        mode_selector = QComboBox()
        mode_selector.addItems(["Sample vs Sample", "Sample vs Reference"])
        layout.addWidget(mode_selector)

        btn_ok = QPushButton("OK")
        layout.addWidget(btn_ok)
        dialog.setLayout(layout)

        def accept():
            dialog.accept()

        btn_ok.clicked.connect(accept)
        dialog.exec()

        mode = mode_selector.currentText()

        try:
            results = []
            if mode == "Sample vs Sample":
                sample_files = self.create_searchable_file_dialog("Select Sample Spectra", self.sample_folder)
                # Check for at least two sample files in the folder
                sample_files_in_folder = os.listdir(self.sample_folder)
                if len(sample_files_in_folder) < 2:
                    QMessageBox.warning(self, "Not Enough Samples", "At least two sample files are required for this analysis.")
                    return
                if len(sample_files) < 2:
                    QMessageBox.warning(self, "Insufficient Selection", "Select at least two sample files for batch analysis.")
                    return
                for i in range(len(sample_files)):
                    for j in range(i + 1, len(sample_files)):
                        f1, f2 = sample_files[i], sample_files[j]
                        # No reference files, so interpolate = False
                        r, rho = run_correlation_analysis(f1, f2, interpolate=False)
                        results.append([
                            os.path.splitext(os.path.basename(f1))[0],
                            os.path.splitext(os.path.basename(f2))[0],
                            r, rho
                        ])
            else:
                # Sample vs Reference
                # Check for reference files in folder
                if not os.listdir(self.reference_folder):
                    QMessageBox.warning(self, "No Reference Files", "No reference files found. Please upload reference files first.")
                    return
                sample_files = self.create_searchable_file_dialog("Select Sample Spectra", self.sample_folder)
                ref_files = self.create_searchable_file_dialog("Select Reference Spectra", self.reference_folder)
                if len(sample_files) == 0 or len(ref_files) == 0:
                    QMessageBox.warning(self, "Insufficient Selection", "Select at least one sample and one reference file for batch analysis.")
                    return
                # Set interpolate True if reference files are present, otherwise False
                interpolate = bool(ref_files)
                for f1 in sample_files:
                    for f2 in ref_files:
                        r, rho = run_correlation_analysis(f1, f2, interpolate=interpolate)
                        results.append([
                            os.path.splitext(os.path.basename(f1))[0],
                            os.path.splitext(os.path.basename(f2))[0],
                            r, rho
                        ])

            if mode == "Sample vs Sample":
                df = pd.DataFrame(results, columns=["Sample 1", "Sample 2", "Pearson R", "Spearman Rho"])
            else:
                df = pd.DataFrame(results, columns=["Sample", "Reference", "Pearson R", "Spearman Rho"])
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            os.makedirs("outputs", exist_ok=True)
            output_path = os.path.join("outputs", f"batch_correlation_results_{timestamp}.csv")
            df.to_csv(output_path, index=False)
            QMessageBox.information(self, "Batch Analysis Complete", f"Batch correlation analysis completed.\nResults saved to: {output_path}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Batch correlation analysis failed:\n{str(e)}")

    def create_searchable_file_dialog(self, title, folder):
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLineEdit, QListWidget, QListWidgetItem, QHBoxLayout, QPushButton
        dialog = QDialog(self)
        dialog.setWindowTitle(title)
        layout = QVBoxLayout()

        search_bar = QLineEdit()
        search_bar.setPlaceholderText("Search...")
        layout.addWidget(search_bar)

        list_widget = QListWidget()
        list_items = []

        files = [f for f in os.listdir(folder) if f.endswith('.csv')]
        for file in sorted(files):
            label = file.replace('.csv', '')
            item = QListWidgetItem(label)
            item.setCheckState(Qt.CheckState.Unchecked)
            list_widget.addItem(item)
            list_items.append(item)

        layout.addWidget(list_widget)

        btn_layout = QHBoxLayout()
        btn_select_all = QPushButton("Select All")
        btn_ok = QPushButton("OK")
        btn_layout.addWidget(btn_select_all)
        btn_layout.addWidget(btn_ok)
        layout.addLayout(btn_layout)

        def toggle_select_all():
            all_checked = all(item.checkState() == Qt.CheckState.Checked for item in list_items if not item.isHidden())
            new_state = Qt.CheckState.Unchecked if all_checked else Qt.CheckState.Checked
            for item in list_items:
                if not item.isHidden():
                    item.setCheckState(new_state)
            btn_select_all.setText("Unselect All" if not all_checked else "Select All")

        def update_toggle_button():
            all_checked = all(item.checkState() == Qt.CheckState.Checked for item in list_items if not item.isHidden())
            btn_select_all.setText("Unselect All" if all_checked else "Select All")

        def accept():
            dialog.accept()

        def filter_list():
            text = search_bar.text().lower()
            for item in list_items:
                item.setHidden(text not in item.text().lower())
            update_toggle_button()

        search_bar.textChanged.connect(filter_list)
        btn_select_all.clicked.connect(toggle_select_all)
        btn_ok.clicked.connect(accept)
        list_widget.itemChanged.connect(update_toggle_button)

        dialog.setLayout(layout)
        dialog.exec()

        selected = [os.path.join(folder, item.text() + '.csv') for item in list_items
                    if item.checkState() == Qt.CheckState.Checked]
        return selected

if __name__ == "__main__":
    app = QApplication(sys.argv)
    viewer = IRViewer()
    viewer.show()
    sys.exit(app.exec())
